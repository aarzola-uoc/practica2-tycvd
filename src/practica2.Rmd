---
title: 'Práctica 2: Limpieza y análisis de datos'
author: "Miguel Santos Pérez  y Alejandro Arzola García"
date: "17 de junio de 2020"
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: '3'
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '3'
subtitle: UOC - Tipología y ciclo de vida de los datos
toc-title: Índice
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,eval=TRUE,echo=FALSE}
# Definir directorio de trabajo para Miguel
# setwd("C:/Users/USER-PC/Desktop/tipologia")
# Definir directorio de trabajo para Alejandro
setwd('/Users/aarzola/Desktop/UOC/1920.S2 - Tipología y ciclo de vida de los datos/PEC_PRAC/PRAC_2/src')
```

\newpage
****

```{r,eval=TRUE,echo=TRUE}
 # Cargamos las librerías necesarias para el proyecto
suppressMessages(library(dplyr)) 
suppressMessages(library(plyr))
```
****

\newpage
# Introducción y descripción de los datasets

En la Práctica 1 de la asginatura de _Tipología y ciclo de vida de los datos_ se creó un proceso _web scraping_ en el que se obtuvieron los datos relacionados a todos los partidos y las estadísticas individuales de todos los jugadores de la actual temporada (2019-2020) de la [\textcolor{blue}{Euroliga}](https://www.euroleague.net/), la máxima competición de clubes de baloncesto de Europa. El objetivo final era contribuir al aumento de explotación de los datos para los equipos europeos y tratar de igualar lo que se realiza en América con las poderosas franquicias de [\textcolor{blue}{NBA}](https://es.nba.com/?gr=www).

Mediante el proceso de obtención de datos realizado en _Python_ que comentamos anteriormente, conseguimos crear dos datasets: el primero contiene los datos generales de un partido (nombre de los equipos, puntuación de cada equipo, fecha y hora del partido) y el segundo contiene más de quince estadísticas individuales para cada jugador por cada partido (puntos, minutos, rebotes, asistencias, ...). Este trabajo está disponible en un repositorio de _GitHub_ al que se puede acceder haciendo click [\textcolor{blue}{aquí}](https://github.com/aarzola-uoc/practica1-tycvd).

El primer dataset (`euroleague_scoreboards.csv`) contiene las siguientes variables:

* **Id:** identificador único de partido.
* **Date:** fecha del partido.
* **HomeTeam:** nombre del equipo local.
* **HomeScore:** puntos anotados por el equipo local.
* **VisitingTeam:** nombre del equipo visitante.
* **VisitingScore:** puntos anotados por el equipo visitante.
* **Link:** enlace a la página web con las estadísticas individuales del partido.

El segundo dataset (`euroleague_stats_per_game.csv`) contiene las siguientes variables:

* **MatchId:** identificador único de partido. 
* **Team:** equipo al que pertenece el jugador. 
* **PlayerNumber:** número del jugador.
* **PlayerName:** nombre del jugador.
* **Min:** minutos jugados.
* **Pts:** puntos anotados.
* **2FG:** tiros de dos (metidos-anotados).
* **3FG:** tiros de tres (metidos-anotados).
* **FT:** tiros libres (metidos-anotados).
* **O:** rebotes ofensivos.
* **D:** rebotes defensivos.
* **T:** rebotes totales.
* **As:** asistencias.
* **St:** recuperaciones.
* **To:** pérdidas.
* **Fv:** tapones a favor.
* **Ag:** tapones en contra.
* **Cm:** faltas cometidas.
* **Rv:** faltas recibidas.
* **PIR:** valoración del jugador.

En esta segunda práctica queremos seguir progresando para lograr el objetivo de igualarnos con la NBA y por ello vamos a utilizar los datasets que hemos mencionado para realizar un análisis estadístico. Este análisis se va a enfocar en analizar las estadísticas globales por partido de cada equipo para tratar de estimar y predecir las victorias de un equipo o definir qué equipos defienden mejor, cuales tienen un mejor ataque y aquellos que tienen una forma de jugar más equilibrada.

Los datasets y el código utilizado para generar el análisis estadístico que se desarrolla a continuación está disponible en el siguiente repositorio de _GitHub_:

* \textcolor{blue}{https://github.com/aarzola-uoc/practica2-tycvd}

****
# Integración y selección de los datos de interés a analizar

Los datos relevantes del primer dataset son exclusivamente los nombres de los equipos y el marcador. Sin embargo, estos datos son posibles calcularlos a partir del segundo dataset, incluso aumentar los datos de equipo ya que son la suma de las estadísticas de todos los jugadores para cada partido.

En base a esto, hemos decidido que se creará un nuevo dataset utilizando código R, a partir del dataset de estadísticas de los jugadores, que tendrá las estadísticas de cada equipo por partido (suma de cada jugador es el total del equipo). El primer dataset se utilizará únicamente como referencia para obtener el equipo oponente de cada partido.

Además vamos a calcular una serie de estadísticos muy interesantes y que permiten un análisis mucho más técnico y útli para los equipos. Estos estadísticos son el ritmo de juego, eficiencia ofensiva/defensiva, porcentaje efectivo de tiros de campo, tasa de rebote y algunos más. La explicación de cada uno de estos estadísticos y su correspondiente fórmula se explicará más adelante.

****
# Limpieza de los datos

El primer paso que tenemos que realizar es cargar los ficheros csv `euroleague_stats_per_game.csv` y `euroleague_scoreboards.csv`. Para ello vamos a utilizar la función `read.csv2` ya que el fichero a cargar está en formato csv español (los separadores son el caracter `;`). Como resultado obtendremos dos objetos `data.frame` que contendrán todos los datos de nuestros dos datasets:

```{r,eval=TRUE,echo=TRUE}
data_scoreboards <- read.csv2('../csv/euroleague_scoreboards.csv', header = TRUE)
data_euroleague <- read.csv2('../csv/euroleague_stats_per_game.csv', header = TRUE)
```

Mostramos los primeros registros de ambos datasets para verificar que los datos se han cargado correctamente:

```{r,eval=TRUE,echo=TRUE}
# Primer dataset (euroleague_scoreboards.csv)
head(data_scoreboards)
```

\newpage
```{r,eval=TRUE,echo=TRUE}
# Segundo dataset (euroleague_stats_per_game.csv)
head(data_euroleague)
```

La variable MatchId es una variable que necesitamos para cruzar ambos datasets. Sin embargo, en el primer dataset, el nombre de esta variable es Id por lo que vamos a homogenizar su nombre:
```{r,eval=TRUE,echo=TRUE}
names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
```

En total disponemos de estadísticas de `r length(table(data_scoreboards$MatchId))` partidos y de `r length(table(data_euroleague$PlayerName))` jugadores diferentes. 

## Elementos vacíos

Los datos vacíos o no definidos pueden presentarse en distintos formatos, normalmente en forma de cadena de caracteres vacía (`""`) o `NA` (_Not Available en inglés_), pero en algunos contextos pueden incluso tomar valores numéricos como 0 o 999. Es fundamental identificar para cada variable los valores que indiquen que existe una pérdida de datos para poder aplicar una solución y que no afecte en la calidad de los análisis estadísticos que se realicen posteriormente.

Procedemos a buscar valores vacíos en nuestro primer dataset:
```{r,eval=TRUE,echo=TRUE}
colSums(is.na(data_scoreboards))
colSums(data_scoreboards=="")
```

Como se puede observar no se ha detectado ningún elemento vacío del tipo `NA` o cadena de caracteres vacía. En el caso de que se haya utilizado valores numéricos fuera del dominio del atributo lo podremos detectar en el análisis de valores extremos.

\newpage
Realizamos el mismo análisis para el segundo dataset. En este caso, como hemos creado nosotros el dataset, sabemos que se ha utilizado el caracter `“-”` para indicar las estadísticas de los jugadores que no han jugado el partido y `“DNP”` (_Did Not Play_) en el atributo de tiempo:

```{r,eval=TRUE,echo=TRUE}
colSums(is.na(data_euroleague))
colSums(data_euroleague=="")
colSums(data_euroleague=="-")
colSums(data_euroleague=="DNP")
```

\newpage
Para solucionar este problema y poder realizar un análisis estadístico en el que se pueda asegurar un nivel alto de calidad de datos, hemos optado por informar todos estos campos con el valor 0:
```{r,eval=TRUE,echo=TRUE}
data_euroleague[is.na(data_euroleague)] <- 0
data_euroleague[data_euroleague=="-"] <- 0
data_euroleague[data_euroleague=="DNP"] <- 0

colSums(is.na(data_euroleague))
colSums(data_euroleague=="")
colSums(data_euroleague=="-")
colSums(data_euroleague=="DNP")
```

Hemos vuelto a buscar elementos vacíos para comprobar que se han solucionado todos los problemas que habíamos detectado y como se puede ver en los fragmentos anteriores se han resuelto todos correctamente.

\newpage
## Tratamiento de variables

El siguiente paso consisten en analizar el tipo de dato que ha asignado R para cada una de nuestras variables al cargar los datasets:

```{r,eval=TRUE,echo=TRUE}
str(data_scoreboards)
```

Para el dataset `data_scoreboards` se han interpretado correctamenta las variables `MatchId`, `HomeScore` y `VisitingTeam` con el tipo de dato `int` ya que son variables cuantitativas discretas, mientras que el resto de variables (`Date`, `HomeTeam` y `VisitingTeam`) que son variables cualitativas nominales, se han interpretado como tipo factor.

Verificamos ahora el segundo dataset:

```{r,eval=TRUE,echo=TRUE}
str(data_euroleague)
```

\newpage
En el segundo dataset vemos que la mayoría de variables se han interpretado como tipo `factor` debido a que muchas contenían elementos vacíos. Como ya hemos solucionado este problema, vamos a proceder a asignar el tipo de dato correspondiente a cada variable:

```{r,eval=TRUE,echo=TRUE}
# Variables cuantitativas discretas
data_euroleague$PlayerNumber <- as.integer(as.character(data_euroleague$PlayerNumber))
data_euroleague$Pts <- as.integer(as.character(data_euroleague$Pts))
data_euroleague$O <- as.integer(as.character(data_euroleague$O))
data_euroleague$D <- as.integer(as.character(data_euroleague$D))
data_euroleague$T <- as.integer(as.character(data_euroleague$T))
data_euroleague$As <- as.integer(as.character(data_euroleague$As))
data_euroleague$St <- as.integer(as.character(data_euroleague$St))
data_euroleague$To <- as.integer(as.character(data_euroleague$To))
data_euroleague$Fv <- as.integer(as.character(data_euroleague$Fv))
data_euroleague$Ag <- as.integer(as.character(data_euroleague$Ag))
data_euroleague$Cm <- as.integer(as.character(data_euroleague$Cm))
data_euroleague$Rv <- as.integer(as.character(data_euroleague$Rv))
data_euroleague$PIR <- as.integer(as.character(data_euroleague$PIR))
```

Verificamos que se han realizado los cambios de tipos de variable:
```{r,eval=TRUE,echo=TRUE}
str(data_euroleague)
```

\newpage
Hemos conseguido limpiar bastante los datos pero aún debemos realizar algunas modificaciones en algunas variables:

* **Min:** la variable minutos la pasaremos a formato decimal.
* **Tiros:** las variables tiros de dos (`X2FG`), tiros de tres (`X3FG`) y tiros libres (`FT`), se encuentran en formato "M/A" donde M es convertidos (_made_) y A intentados (_attempts_). Por cada una de ellas, crearemos por lo tanto dos variables, separando los aciertos de los intentos.

```{r,eval=TRUE,echo=TRUE}
# Modificamos la variable tiempo
levels(data_euroleague$Min) <- c(levels(data_euroleague$Min), "0:00")
data_euroleague$Min[data_euroleague$Min=="0"] <- "0:00"

data_euroleague$Min <- sapply(strsplit(as.character(data_euroleague$Min),":"),
  function(x) {
    x <- as.numeric(x)
    x[1]+x[2]/60
  })
```

```{r,eval=TRUE,echo=TRUE}
# Modificamos la variables tiros de 2
levels(data_euroleague$X2FG) <- c(levels(data_euroleague$X2FG), "0/0")
data_euroleague$X2FG[data_euroleague$X2FG=="0"] <- "0/0"

data_euroleague$x2M <- sapply(strsplit(as.character(data_euroleague$X2FG),"/"),
  function(x) {
    x <- as.integer(x)
    x[1]
  })

data_euroleague$x2A <- sapply(strsplit(as.character(data_euroleague$X2FG),"/"),
  function(x) {
    x <- as.integer(x)
    x[2]
  })

data_euroleague$X2FG <- NULL
```

```{r,eval=TRUE,echo=TRUE}
# Modificamos la variables tiros de 3
levels(data_euroleague$X3FG) <- c(levels(data_euroleague$X3FG), "0/0")
data_euroleague$X3FG[data_euroleague$X3FG=="0"] <- "0/0"

data_euroleague$x3M <- sapply(strsplit(as.character(data_euroleague$X3FG),"/"),
  function(x) {
    x <- as.integer(x)
    x[1]
  })

data_euroleague$x3A <- sapply(strsplit(as.character(data_euroleague$X3FG),"/"),
  function(x) {
    x <- as.integer(x)
    x[2]
  })

data_euroleague$X3FG <- NULL
```

\newpage
```{r,eval=TRUE,echo=TRUE}
# Modificamos la variables tiros libres
levels(data_euroleague$FT) <- c(levels(data_euroleague$FT), "0/0")
data_euroleague$FT[data_euroleague$FT=="0"] <- "0/0"

data_euroleague$FTM <- sapply(strsplit(as.character(data_euroleague$FT),"/"),
  function(x) {
    x <- as.integer(x)
    x[1]
  })

data_euroleague$FTA <- sapply(strsplit(as.character(data_euroleague$FT),"/"),
  function(x) {
    x <- as.integer(x)
    x[2]
  })

data_euroleague$FT <- NULL
```

Realizamos la última comprobación de los tipos de datos de las variables del dataset `data_euroleague`:
```{r,eval=TRUE,echo=TRUE}
sapply(data_euroleague, function(x) class(x))
```

Por tanto, el resumen es el siguiente:

* Variables cualitativas nominales: `Team`, `PlayerName` (tipo `factor`).
* Variables cuantitativas discretas: `MatchId`, `PlayerNumber`, `Pts`, `O`, `D`, `T`, `As`, `St`, `To`, `Fv`, `Ag`, `Cm`, `Rv`, `PIR`, `x2M`, `x2A`, `x3M`, `x3A`, `FTM`, `FTA` (tipo `integer`).
* Variables cuantitativas continuas: `Min` (tipo `numeric`).

\newpage
## Agregación de datos

Como previamente comentamos en el [\textcolor{blue}{apartado}](#integración-y-selección-de-los-datos-de-interés-a-analizar) de integración y selección de datos de interés, la idea principal es crear un nuevo dataset que agrupe las estadísticas para cada equipo y partido. Por tanto, el resultado será la suma de las estadísticas de todos los jugadores del equipo para cada partido. Este nuevo dataset se llamará `data_team`:

```{r,eval=TRUE,echo=TRUE}
data_team <- as.data.frame(data_euroleague %>% group_by(Team, MatchId) %>%
  select_if(is.numeric) %>%
  summarise_each(list(sum)))

data_team[c("PlayerNumber")] <- NULL
```

Mostramos los primeros registros de este nuevo dataset:
```{r,eval=TRUE,echo=TRUE}
head(data_team)
```

A primera vista este dataset se ha creado correctamente. Como prueba de la calidad de los datos y del proceso de transformación podemos comprobar que los minutos de los partidos son correctos:

`5 jugadores * 10 mintuos * 4 cuartos = 200 minutos`

Para los partidos con prórroga se deben sumar 5 minutos por cada parte de tiempo extra y multiplicar por los 5 jugadores. Por eso vemos partidos con 225 minutos.

\newpage
## Identificación y tratamiento de valores extremos

Los valores extremos (_extreme scores_ o _outliers_) son aquellos datos que se encuentran muy alejados de la distribución normal de una variable o población. Generalmente se considera que cuando un valor se encuentra alejado 3 desviaciones estándar con respecto a la media del conjunto es un _outlier_. Para encontrar estos valores extremos se utiliza los diagramas de cajas o _boxplot_, que permiten identificar de manera muy sencilla si existen valores extremos para una determinada variable.

Para detectar los valores extremos de nuestro dataset de estadísticas de equipo, vamos a crear un diagrama de caja por cada variable cuantitativa:


****
\newpage
# Enriquecimiento de los datos
## Datos del oponente.
Durante un encuentro de baloncesto, es tan importante medir lo que tu equipo ha hecho como lo que tu equipo ha recibido. Por lo tanto, buscamos enriquecer la información por partido de cada equipo añadiendo la información del oponente. Para ello, utilizaremos la tabla de scores para completar así los registros.

```{r,eval=TRUE,echo=TRUE}
names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "VisitingTeam"] <- "Opponent"


df_1 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_1["Local"] <- 1


names(data_scoreboards)[names(data_scoreboards) == "Team"] <- "HomeTeam"
names(data_scoreboards)[names(data_scoreboards) == "Opponent"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Opponent"
df_2 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_2["Local"] <- 0

data_team <- bind_rows(df_1,df_2)

data_team[c("Date")] <- NULL
data_team[c("HomeScore")] <- NULL
data_team[c("VisitingScore")] <- NULL
data_team[c("Link")] <- NULL

data_team2 <- data_team [c("MatchId","Team","Min","Pts","O","D","T","As","St","To","Fv","Ag","Cm","Rv","PIR","x2M","x2A","x3M","x3A","FTM","FTA")]

names(data_team2)[names(data_team2) == "Pts"] <- "Pts_Opp"
names(data_team2)[names(data_team2) == "O"] <- "O_Opp"
names(data_team2)[names(data_team2) == "D"] <- "D_Opp"
names(data_team2)[names(data_team2) == "T"] <- "T_Opp"
names(data_team2)[names(data_team2) == "As"] <- "As_Opp"
names(data_team2)[names(data_team2) == "St"] <- "St_Opp"
names(data_team2)[names(data_team2) == "To"] <- "To_Opp"
names(data_team2)[names(data_team2) == "Fv"] <- "Fv_Opp"
names(data_team2)[names(data_team2) == "Ag"] <- "Ag_Opp"
names(data_team2)[names(data_team2) == "Cm"] <- "Cm_Opp"
names(data_team2)[names(data_team2) == "Rv"] <- "Rv_Opp"
names(data_team2)[names(data_team2) == "PIR"] <- "PIR_Opp"
names(data_team2)[names(data_team2) == "x2M"] <- "x2M_Opp"
names(data_team2)[names(data_team2) == "x2A"] <- "x2A_Opp"
names(data_team2)[names(data_team2) == "x3M"] <- "x3M_Opp"
names(data_team2)[names(data_team2) == "x3A"] <- "x3A_Opp"
names(data_team2)[names(data_team2) == "FTM"] <- "FTM_Opp"
names(data_team2)[names(data_team2) == "FTA"] <- "FTA_Opp"

data_teamopp <- merge(data_team, data_team2, by.x=c("MatchId","Opponent"),  by.y=c("MatchId","Team"))
data_teamopp["y.min"]<-NULL
```



## Creación de nuevas métricas 

Durante los últimos años, se ha dado una vuelta al análisis de la estadísticas en baloncesto. Como los diferentes equipos, de acuerdo a su estilo, juegan a distintos ritmos, no podemos usar los promedios por partido para compararlos.
Para poder lograr las comparaciones hay definir el concepto de las posesiones, que es la base de estos cálculos. El basket es un juego en el que ambos equipos se alternan la posesión de la pelota. El equipo que aproveche mejor sus posesiones será el equipo ganador.
Se entiende que una posesión termina con un tiro al aro, una pérdida de balón o un tiro libre. Allí el balón pasa al rival y la posesión se termina.
¿Qué ocurre si el equipo falla el tiro de campo pero captura el rebote ofensivo? Hoy por hoy, la mayoría de los estadistas de baloncesto consideran que no se le debe anotar una nueva posesión al equipo, sino considerar que la misma posesión continúa.   

Para tener en cuenta lo anteriormente mencionado, definimos las métricas a continuación

### Pace o Ritmo

Nos da una idea del ritmo de juego del equipo, expresado en cantidad de posesiones por juego que utiliza. Hay equipos que corren más y equipos que prefieren el juego estático. Por eso las estadísticas por juego NO sirven para comparar equipos.
Las posesiones se calculan con la siguiente fórmula:
$Pos = FGA – OR + TO + (FTA*0.4)$
donde 
- Pos: posesiones
- FGA (field goal attempts): lanzamientos de campo (tanto de 2 y de 3)
- OR (ofensive rebounds): rebotes ofensivos
- TO (turnovers): pelotas perdidas
- FTA (free throw attempts): tiros libres lanzados

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Poss"] <- +data_teamopp["x2A"] +data_teamopp["x3A"] -data_teamopp["O"] +data_teamopp["To"]+0.4*data_teamopp["FTA"]
```


### Rating ofensivo y defensivo
Evaluamos el aspecto ofensivo, defensivo y la diferencia entre ambos.

#### Eficiencia ofensiva (Rating ofensivo)
Habitualmente se evalúa la ofensiva en puntos convertidos por juego, lo cual es una manera un tanto absurda. Si pensamos el juego como una serie de posesiones, el equipo que más puntos convierta en sus posesiones, será el más efectivo. Se multiplica por 100 para expresar los puntos cada 100 posesiones, y no manejar números con decimales. Así:

$Offensive Rating = (puntos/posesiones)*100$

#### Eficiencia defensiva (Rating defensivo)
Así como medimos la eficiencia ofensiva en base a puntos convertidos cada 100 posesiones, podemos medir la defensa en base a puntos recibidos (o puntos del oponente) cada 100 posesiones del equipo contrario.

$Defensive Rating = (puntos_{oponente}/posesiones)*100$


```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Off_Rat"] <- +data_teamopp["Pts"]/data_teamopp["Poss"]

data_teamopp ["Def_Rat"] <- +data_teamopp["Pts_Opp"]/data_teamopp["Poss"]
```


### Porcentaje efectivo de tiros de campo (eFG%)
Esta estadística ajusta los tiros de campo dandole el valor extra (un punto más) a los triples. Esto corrige el FG% común que subestima a los triples. Por ejemplo, si un jugador ha hecho 2/5 en T2 y 1/4 en T3, habrá convertido 3/9 en tiros de campo (33%), que es similar a si hubiera metido 3/5 de T2 y 0/4 en T3. Sin embargo, en el primer supuesto ha conseguido más puntos para el equipo. Así, el eFG% del primero será 44.4% que se ajusta más a la realidad. La fórmula, por tanto es:

$eFG\% = (FGM + 0.5*3PM) / FGA$

FGM (field goal made): tiros de campo convertidos
3PM (3 points made): triples convertidos
FGA (field goal attempts): tiros de campo intentados

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["eFG"] <- (data_teamopp["x2M"]+1.5*data_teamopp["x3M"])/ (data_teamopp["x2A"]+data_teamopp["x3A"])

data_teamopp ["eFG_Opp"] <- (data_teamopp["x2M_Opp"]+1.5*data_teamopp["x3M_Opp"])/ (data_teamopp["x2A_Opp"]+data_teamopp["x3A_Opp"])
```

### True Shooting (TS) o Lanzamientos reales
Esta métrica tiene en cuenta los dobles, triples y tiros libres, para dar una idea de cómo tira el jugador globalmente. Ejemplo: en la 2009-2010, Martin Leiva quedó #8 en FG% con 58,72. Pero si le agregamos los libres, cae al puesto #91 con 54.8%. La formula es:

$TS = puntos / (2*(FGA+0.44*FTA)$

- FGA (field goal attempts): lanzamientos de cancha intentados
- FTA (free throw attempts): tiros libres intentados

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["TS"] <- data_teamopp["Pts"] /  (data_teamopp["x2A"]+data_teamopp["x3A"]+0.44*data_teamopp["FTA"])

data_teamopp ["TS_Opp"] <- data_teamopp["Pts_Opp"] /  (data_teamopp["x2A_Opp"]+data_teamopp["x3A_Opp"]+0.44*data_teamopp["FTA_Opp"])
```

### Rebotes
Los rebotes totales de un equipo son de poco valor. Capturar un rebote ofensivo requiere diferentes habilidades que capturar uno defensivo, por lo que deben analizarse por separado.
Tener en cuenta el número absoluto de rebotes conseguidos, o el promedio de rebotes por partido, nos puede llevar a errores, ya que los rebotes ´disponibles´ dependen de la efectividad: si un equipo falla poco, hay pocos rebotes por tomar. Ejemplo: el equipo A tomó en un partido 20 rebotes defensivos. Si  el equipo B falló 30 lanzamientos (o sea que hubo 30 rebotes en el aro defensivo de A) entonces A capturó 66% de los rebotes en su aro (20 de 30). Pero si B erró 25 tiros, A tomó 80% de los rebotes (20 de 25).
Esto hace que, para evaluarlo correctamente, definamos: DR% como porcentaje de rebotes defensivos y OR% porcentaje de rebotes ofensivos.  

#### Tasa de rebotes ofensivos
$\% de rebotes ofensivos = [OR/(OR+op DR)]*100$

- OR (ofensive rebounds): rebotes ofensivos
- Op DR (oponent defensive rebounds): rebotes defensivos del rival

#### Tasa de rebotes defensivos
$\% de rebotes defensivos = [DR/(DR+op OR)]*100$

- DR (defensive rebounds): rebotes defensivos
- Op OR (oponent ofensive rebounds): rebotes ofensivos del rival

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Off_Reb"] <- data_teamopp["O"] /  (data_teamopp["O"]+data_teamopp["D_Opp"])

data_teamopp ["Def_Reb"] <- data_teamopp["D"] /  (data_teamopp["D"]+data_teamopp["O_Opp"])
```

### Porcentaje de asistencias y pérdidas
Al igual que con los rebotes y otras estadísitcas, las asistencias por juego no son un buen parámetro, ya que dependen del ritmo de juego. Más preciso es calcular las asistencias expresadas en posesiones terminan con una pérdida de balón. Habitualmente expresado en porcentaje.

### Porcentaje de asistencias
Se calculan mediante la siguiente fórmula:

$\% de asistencias = (asistencias/posesiones)*100$

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Pct_ass"] <- data_teamopp["As"] /  (data_teamopp["Poss"])

data_teamopp ["Pct_ass_opp"] <- data_teamopp["As_Opp"] /  (data_teamopp["Poss"])
```

#### Porcentaje de pérdidas
Lo mismo ocurre con las pérdidas. No es lo mismo perder 10 pelotas en un partido en que hubo 100 posesiones, que en uno que hubo 80. Por eso es mejor calcular las pérdidas cada 100 posesiones. El valor ideal depende del ritmo de juego, pero podríamos decir que el objetivo sería tener menos de 15% de TO y provocar en el oponente más de 15%.
La fórmula es:
$\% de pérdidas = (pelotas pérdidas/posesiones)*100$

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Pct_To"] <- data_teamopp["To"] /  (data_teamopp["Poss"])

data_teamopp ["Pct_To_opp"] <- data_teamopp["To_Opp"] /  (data_teamopp["Poss"])
```

#### Tiros libres, respecto a tiros de campo (FTM/FGA)
Es simplemente una manera de expresar el número de veces que un equipo va a la línea y cuántas veces envía al oponente a la línea. Esta considerado (junto con el effective field goal percentage, la tasa de rebotes ofensivos y la tasa de pérdidas) uno de los cuatro factores con los que se miden los partidos. 
La fórmula es:
$ Libres por lanzamientos de cancha = (libres convertidos/tiros de cancha intentados) * 100$

```{r,eval=TRUE,echo=TRUE}
data_teamopp["FTR"] <- data_teamopp["FTM"] /  (data_teamopp["x2A"]+ data_teamopp["x3A"])

data_teamopp["FTR_opp"] <- data_teamopp["FTM_Opp"] /  (data_teamopp["x2A_Opp"]+ data_teamopp["x3A_Opp"])
```

### Expected wins (triunfos esperados)
Para ganar, obviamente hay que meter más puntos que el rival. Existe un cálculo (comprobado en la NBA, baloncesto FIBA y universitario) que de acuerdo a los puntos convertidos y recibidos, se puede estimar la cantidad de partidos que habría que haber ganado. Suele correlacionar muy bien con la realidad. 

$Triunfos esperados = eficiencia ofensiva^14/(eficiencia ofensiva^14+eficiencia defensiva^14)$

```{r,eval=TRUE,echo=TRUE}
data_teamopp ["Expected_Wins"] <- data_teamopp["Off_Rat"]^14 /  (data_teamopp["Off_Rat"]^14+data_teamopp["Def_Rat"]^14)
```


****
# Análisis de los datos

FALTA POR HACER

## Selección de los grupos de datos que se quieren analizar/comparar
## Comprobación de la normalidad y homogeneidad de la varianza
## Pruebas estadísticas para comparar los grupos de datos

### Regresión lineal para estimar los ratings

```{r,eval=TRUE,echo=TRUE}
#data_teamopp["Off_Reb_Opp"]<-1-data_teamopp["Def_Reb"]

#library(data.table)
#data_ataque <- data_teamopp[c("Off_Rat","eFG","Off_Reb","Pct_To","FTR")]

#corr_ataque <- round(cor(data_ataque),2)

#library(ggcorrplot)
#ggcorrplot(corr_ataque, type = "upper",
#   lab = TRUE)

#model_offesive_rating<- lm(Off_Rat~., data=data_ataque)
#summary(model_offesive_rating)


#data_defensa <- data_teamopp[c("Def_Rat","eFG_Opp","Off_Reb_Opp","Pct_To_opp","FTR_opp")]
#corr_defensa <- round(cor(data_defensa),2)

#ggcorrplot(corr_defensa, type = "upper",
#   lab = TRUE)

#model_defensive_rating<- lm(Def_Rat~., data=data_defensa)
#summary(model_defensive_rating)
```

### Regresión logística para estimar victoria
Buscamos estimar la probabibilidad de victoria en función de los estadísticos creados. 
```{r,eval=TRUE,echo=TRUE}
#datos_logit<-data_teamopp[c("eFG","Off_Reb","Pct_To","FTR","eFG_Opp","Off_Reb_Opp","Pct_To_opp","FTR_opp","Win","Local")]

#model_victoria <- glm(formula=Win ~ . , data=datos_logit, family=binomial)
#summary(model_victoria)
```

```{r}
#library(pROC)
#rocobj <- roc( datos_logit$Win, predict(model_victoria, datos_logit), auc = TRUE, ci = TRUE )
#print(rocobj)

#plot.roc( rocobj, legacy.axes = TRUE, print.thres = "best", print.auc = TRUE, auc.polygon = FALSE, max.auc.polygon = FALSE, auc.polygon.col="gainsboro", col = 2, grid = TRUE )
```

### Clustering de jugadores

****
# Exportación de datos finales

A continuación vamos a exportar nuestros dataframes finales a un archivo csv. Estos archivos se llamarán euroleague_scoreboards_clean.csv, euroleague_stats_per_game_clean.csv y euroleague_stats_per_team_clean.cs Utilizamos la función write.csv2() para exportar el fichero en formato csv español:

```{r,eval=TRUE,echo=TRUE}
write.csv2(data_scoreboards, row.names = FALSE, 
           file = "../csv/euroleague_scoreboards_clean.csv")

write.csv2(data_euroleague, row.names = FALSE, 
           file = "../csv/euroleague_stats_per_game_clean.csv")

write.csv2(data_team, row.names = FALSE, 
           file = "../csv/euroleague_stats_per_team_clean.csv")
```

Estos nuevos datasets también estarán disponibles en el repositorio de GitHub mencionado en el primer apartado de este documento.

****
# Representación de los resultados a partir de tablas y gráficas

FALTA POR HACER

****
# Resolución del problema

FALTA POR HACER

****
# Contribuciones al trabajo

**Contribuciones**              |  **Firma**                    | 
--------------------------------|:-----------------------------:|
Selección del dataset           | MSP, AAG
Creación del repositorio GitHub | MSP, AAG
Desarrollo código en R          | MSP, AAG
Redacción de las respuestas     | MSP, AAG