---
title: 'Práctica 2: Limpieza y análisis de datos'
author: "Miguel Santos Pérez  y Alejandro Arzola García"
date: "17 de junio de 2020"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../pdf") })
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: '2'
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '2'
subtitle: UOC - Tipología y ciclo de vida de los datos
toc-title: Índice
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage
# Descripción del dataset

En la Práctica 1 de la asginatura de _Tipología y ciclo de vida de los datos_ se creó un proceso _web scraping_ en el que se obtuvieron los datos relacionados a todos los partidos y las estadísticas individuales de todos los jugadores de la actual temporada (2019-2020) de la [\textcolor{blue}{Euroliga}](https://www.euroleague.net/), la máxima competición de clubes de baloncesto de Europa. 

El objetivo final era contribuir al aumento de explotación de los datos para los equipos europeos y tratar de igualar lo que se realiza en América con las poderosas franquicias de [\textcolor{blue}{NBA}](https://es.nba.com/?gr=www).

Mediante el proceso de obtención de datos realizado en _Python_ que comentamos anteriormente, conseguimos crear dos datasets: el primero contiene los datos generales de un partido (nombre de los equipos, puntuación de cada equipo, fecha y hora del partido) y el segundo contiene más de quince estadísticas individuales para cada jugador por cada partido (puntos, minutos, rebotes, asistencias, ...). Este trabajo está disponible en un repositorio de _GitHub_ al que se puede acceder haciendo click [\textcolor{blue}{aquí}](https://github.com/aarzola-uoc/practica1-tycvd).

Para esta segunda práctica queremos seguir progresando para lograr este objetivo y por ello vamos a utilizar los datasets que hemos mencionado para realizar un análisis estadístico.

Los datasets y el código utilizado para generar el análisis estadístico que se desarrolla a continuación está disponible en el siguiente repositorio de _GitHub_:

* \textcolor{blue}{https://github.com/aarzola-uoc/practica2-tycvd}

****
# Integración y selección de los datos de interés a analizar

Tras realizar un análisis en profundidad de los dos datasets de los que disponemos, hemos tomado la decisión de utilizar únicamente el que contiene las estadísticas individuales por partido de cada jugador. 

Los datos relevantes del primer dataset son exclusivamente los nombres de los equipos y el marcador. Sin embargo, estos datos son posibles calcularlos a partir del segundo dataset, incluso aumentar los datos de equipo ya que son la suma de las estadísticas de todos los jugadores para cada partido.

En base a esto, hemos decidido que se creará un nuevo dataset utilizando código R, a partir del dataset de estadísticas de los jugadores, que tendrá las estadísticas de cada equipo por partido (suma de cada jugador es el total del equipo).

Además vamos a calcular una serie de estadísticos muy interesantes y que permiten un análisis mucho más técnico y útli para los equipos. Estos estadísticos son.....
**FALTA POR HACER (Miguel): definición de estadísticos**


# 0. Carga de ficheros

Una vez realizado el webscrapping, cargamos los ficheros en $R$ para trabajar con ellos. 

```{r}
setwd("C:/Users/USER-PC/Desktop/tipologia")

data_scoreboards <- read.csv(file="euroleague_scoreboards.csv", header=TRUE,  sep=";", stringsAsFactors = FALSE)
data_euroleague <- read.csv(file="euroleague_stats_per_game.csv", header=TRUE, sep=";", stringsAsFactors = FALSE)
```

*MatchId* es una variable que necesitamos para cruzar ambos dataset. Por lo tanto, homogeneizamos su nombre.

```{r}
names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
```




# 1. Preprocesamiento de datos
## 1.1 Asignación de missings

Realizamos el preprocesamiento de datos. Informaremos como 0 aquellas variables sin informar, ya que son realmente 0s puesto que corresponden a jugadores que no han jugado.

```{r}
data_euroleague$Pts[data_euroleague$Pts=="-"]<-"0"
data_euroleague$Pts <- as.numeric(data_euroleague$Pts)

data_euroleague$O[data_euroleague$O=="-"]<-"0"
data_euroleague$O <- as.numeric(data_euroleague$O)

data_euroleague$D[data_euroleague$D=="-"]<-"0"
data_euroleague$D <- as.numeric(data_euroleague$D)

data_euroleague$T[data_euroleague$T=="-"]<-"0"
data_euroleague$T <- as.numeric(data_euroleague$T)

data_euroleague$As[data_euroleague$As=="-"]<-"0"
data_euroleague$As <- as.numeric(data_euroleague$As)

data_euroleague$St[data_euroleague$St=="-"]<-"0"
data_euroleague$St <- as.numeric(data_euroleague$St)

data_euroleague$To[data_euroleague$To=="-"]<-"0"
data_euroleague$To <- as.numeric(data_euroleague$To)

data_euroleague$Fv[data_euroleague$Fv=="-"]<-"0"
data_euroleague$Fv <- as.numeric(data_euroleague$Fv)

data_euroleague$Ag[data_euroleague$Ag=="-"]<-"0"
data_euroleague$Ag <- as.numeric(data_euroleague$Ag)

data_euroleague$Cm[data_euroleague$Cm=="-"]<-"0"
data_euroleague$Cm <- as.numeric(data_euroleague$Cm)

data_euroleague$Rv[data_euroleague$Rv=="-"]<-"0"
data_euroleague$Rv <- as.numeric(data_euroleague$Rv)

data_euroleague$PIR[data_euroleague$PIR=="-"]<-"0"
data_euroleague$PIR <- as.numeric(data_euroleague$PIR)

## Modificamos la variable tiempo
data_euroleague$Min[data_euroleague$Min=="0"]<-"0:00"
data_euroleague$Min[data_euroleague$Min=="DNP"]<-"0:00"
```

## 1.2 Tratamiento de variables
Para poder trabajar con las variables, necesitamos tratarlas. Así, realizaremos las siguientes modificaciones:
- *Min*: La variable minutos la pasaremos a formato decimal.
- *Tiros*: Las variables tiros de dos, tiros de tres y tiros libres, se encuentran en formato "M/A" donde M es convertidos (made) y A intentados (attempts). Por cada una de ellas, crearemos por lo tanto dos variables, separando los aciertos de los intentos.
- **

```{r}
data_euroleague$Min <- sapply(strsplit(data_euroleague$Min,":"),
  function(x) {
    x <- as.numeric(x)
    x[1]+x[2]/60
    }
)

## Modificamos la variables tiros de 2
data_euroleague$X2FG[data_euroleague$X2FG=="-"]<-"0/0"
data_euroleague$X2FG[data_euroleague$X2FG=="0"]<-"0/0"
data_euroleague$x2M <- sapply(strsplit(data_euroleague$X2FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$x2A <- sapply(strsplit(data_euroleague$X2FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)


## Modificamos la variables tiros de 3
data_euroleague$X3FG[data_euroleague$X3FG=="-"]<-"0/0"
data_euroleague$X3FG[data_euroleague$X3FG=="0"]<-"0/0"
data_euroleague$x3M <- sapply(strsplit(data_euroleague$X3FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$x3A <- sapply(strsplit(data_euroleague$X3FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)


## Modificamos la variables tiros libres
data_euroleague$FT[data_euroleague$FT=="-"]<-"0/0"
data_euroleague$FT[data_euroleague$FT=="0"]<-"0/0"
data_euroleague$FTM <- sapply(strsplit(data_euroleague$FT,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$FTA <- sapply(strsplit(data_euroleague$FT,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)
```

## 1.3 Agregación de datos

Para cada equipo y partido agregamos los datos.

```{r}
library(dplyr)
data_team <- data_euroleague %>% group_by(Team, MatchId) %>%
  select_if(is.numeric) %>%
  summarise_each(funs(sum))

data_team[c("PlayerNumber")] <- NULL
```

## 1.4 Enriquecimiento de los datos. Datos del oponente.
Durante un encuentro de baloncesto, es tan importante medir lo que tu equipo ha hecho como lo que tu equipo ha recibido. Por lo tanto, buscamos enriquecer la información por partido de cada equipo añadiendo la información del oponente. Para ello, utilizaremos la tabla de scores para completar así los registros.

```{r}
library(dplyr)

names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "VisitingTeam"] <- "Opponent"


library(plyr)
df_1 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_1["Local"] <- 1


names(data_scoreboards)[names(data_scoreboards) == "Team"] <- "HomeTeam"
names(data_scoreboards)[names(data_scoreboards) == "Opponent"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Opponent"
df_2 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_2["Local"] <- 0

data_team <- bind_rows(df_1,df_2)

data_team[c("Date")] <- NULL
data_team[c("HomeScore")] <- NULL
data_team[c("VisitingScore")] <- NULL
data_team[c("Link")] <- NULL

data_team2 <- data_team [c("MatchId","Team","Min","Pts","O","D","T","As","St","To","Fv","Ag","Cm","Rv","PIR","x2M","x2A","x3M","x3A","FTM","FTA")]

names(data_team2)[names(data_team2) == "Pts"] <- "Pts_Opp"
names(data_team2)[names(data_team2) == "O"] <- "O_Opp"
names(data_team2)[names(data_team2) == "D"] <- "D_Opp"
names(data_team2)[names(data_team2) == "T"] <- "T_Opp"
names(data_team2)[names(data_team2) == "As"] <- "As_Opp"
names(data_team2)[names(data_team2) == "St"] <- "St_Opp"
names(data_team2)[names(data_team2) == "To"] <- "To_Opp"
names(data_team2)[names(data_team2) == "Fv"] <- "Fv_Opp"
names(data_team2)[names(data_team2) == "Ag"] <- "Ag_Opp"
names(data_team2)[names(data_team2) == "Cm"] <- "Cm_Opp"
names(data_team2)[names(data_team2) == "Rv"] <- "Rv_Opp"
names(data_team2)[names(data_team2) == "PIR"] <- "PIR_Opp"
names(data_team2)[names(data_team2) == "x2M"] <- "x2M_Opp"
names(data_team2)[names(data_team2) == "x2A"] <- "x2A_Opp"
names(data_team2)[names(data_team2) == "x3M"] <- "x3M_Opp"
names(data_team2)[names(data_team2) == "x3A"] <- "x3A_Opp"
names(data_team2)[names(data_team2) == "FTM"] <- "FTM_Opp"
names(data_team2)[names(data_team2) == "FTA"] <- "FTA_Opp"

data_teamopp <- merge(data_team, data_team2, by.x=c("MatchId","Opponent"),  by.y=c("MatchId","Team"))
data_teamopp["y.min"]<-NULL
```



#2. Creación de nuevas métricas 

Durante los últimos años, se ha dado una vuelta al análisis de la estadísticas en baloncesto. Como los diferentes equipos, de acuerdo a su estilo, juegan a distintos ritmos, no podemos usar los promedios por partido para compararlos.
Para poder lograr las comparaciones hay definir el concepto de las posesiones, que es la base de estos cálculos. El basket es un juego en el que ambos equipos se alternan la posesión de la pelota. El equipo que aproveche mejor sus posesiones será el equipo ganador.
Se entiende que una posesión termina con un tiro al aro, una pérdida de balón o un tiro libre. Allí el balón pasa al rival y la posesión se termina.
¿Qué ocurre si el equipo falla el tiro de campo pero captura el rebote ofensivo? Hoy por hoy, la mayoría de los estadistas de baloncesto consideran que no se le debe anotar una nueva posesión al equipo, sino considerar que la misma posesión continúa.   

Para tener en cuenta lo anteriormente mencionado, definimos las métricas a continuación

#2.1 Pace o Ritmo.

Nos da una idea del ritmo de juego del equipo, expresado en cantidad de posesiones por juego que utiliza. Hay equipos que corren más y equipos que prefieren el juego estático. Por eso las estadísticas por juego NO sirven para comparar equipos.
Las posesiones se calculan con la siguiente fórmula:
$Pos = FGA – OR + TO + (FTA*0.4)$
donde 
- Pos: posesiones
- FGA (field goal attempts): lanzamientos de campo (tanto de 2 y de 3)
- OR (ofensive rebounds): rebotes ofensivos
- TO (turnovers): pelotas perdidas
- FTA (free throw attempts): tiros libres lanzados

```{r}
data_teamopp ["Poss"] <- +data_teamopp["x2A"] +data_teamopp["x3A"] -data_teamopp["O"] +data_teamopp["To"]+0.4*data_teamopp["FTA"]
```


##2.2 Rating ofensivo y defensivo
Evaluamos el aspecto ofensivo, defensivo y la diferencia entre ambos.

### 2.2.1 Eficiencia ofensiva (Rating ofensivo)
Habitualmente se evalúa la ofensiva en puntos convertidos por juego, lo cual es una manera un tanto absurda. Si pensamos el juego como una serie de posesiones, el equipo que más puntos convierta en sus posesiones, será el más efectivo. Se multiplica por 100 para expresar los puntos cada 100 posesiones, y no manejar números con decimales. Así:

$Offensive Rating = (puntos/posesiones)*100$

### 2.2.1 Eficiencia defensiva (Rating defensivo)
Así como medimos la eficiencia ofensiva en base a puntos convertidos cada 100 posesiones, podemos medir la defensa en base a puntos recibidos (o puntos del oponente) cada 100 posesiones del equipo contrario.

$Defensive Rating = (puntos_{oponente}/posesiones)*100$


```{r}
data_teamopp ["Off_Rat"] <- +data_teamopp["Pts"]/data_teamopp["Poss"]

data_teamopp ["Def_Rat"] <- +data_teamopp["Pts_Opp"]/data_teamopp["Poss"]
```


## 2.3 Porcentaje efectivo de tiros de campo (eFG%).
Esta estadística ajusta los tiros de campo dandole el valor extra (un punto más) a los triples. Esto corrige el FG% común que subestima a los triples. Por ejemplo, si un jugador ha hecho 2/5 en T2 y 1/4 en T3, habrá convertido 3/9 en tiros de campo (33%), que es similar a si hubiera metido 3/5 de T2 y 0/4 en T3. Sin embargo, en el primer supuesto ha conseguido más puntos para el equipo. Así, el eFG% del primero será 44.4% que se ajusta más a la realidad. La fórmula, por tanto es:

$eFG% = (FGM + 0.5*3PM) / FGA$

FGM (field goal made): tiros de campo convertidos
3PM (3 points made): triples convertidos
FGA (field goal attempts): tiros de campo intentados

```{r}
data_teamopp ["eFG"] <- (data_teamopp["x2M"]+1.5*data_teamopp["x3M"])/ (data_teamopp["x2A"]+data_teamopp["x3A"])

data_teamopp ["eFG_Opp"] <- (data_teamopp["x2M_Opp"]+1.5*data_teamopp["x3M_Opp"])/ (data_teamopp["x2A_Opp"]+data_teamopp["x3A_Opp"])
```

## 2.4 True Shooting (TS) o Lanzamientos reales
Esta métrica tiene en cuenta los dobles, triples y tiros libres, para dar una idea de cómo tira el jugador globalmente. Ejemplo: en la 2009-2010, Martin Leiva quedó #8 en FG% con 58,72. Pero si le agregamos los libres, cae al puesto #91 con 54.8%. La formula es:

$TS = puntos / (2*(FGA+0.44*FTA)$

- FGA (field goal attempts): lanzamientos de cancha intentados
- FTA (free throw attempts): tiros libres intentados

```{r}
data_teamopp ["TS"] <- data_teamopp["Pts"] /  (data_teamopp["x2A"]+data_teamopp["x3A"]+0.44*data_teamopp["FTA"])

data_teamopp ["TS_Opp"] <- data_teamopp["Pts_Opp"] /  (data_teamopp["x2A_Opp"]+data_teamopp["x3A_Opp"]+0.44*data_teamopp["FTA_Opp"])
```

## 2.5 Rebotes.
Los rebotes totales de un equipo son de poco valor. Capturar un rebote ofensivo requiere diferentes habilidades que capturar uno defensivo, por lo que deben analizarse por separado.
Tener en cuenta el número absoluto de rebotes conseguidos, o el promedio de rebotes por partido, nos puede llevar a errores, ya que los rebotes ´disponibles´ dependen de la efectividad: si un equipo falla poco, hay pocos rebotes por tomar. Ejemplo: el equipo A tomó en un partido 20 rebotes defensivos. Si  el equipo B falló 30 lanzamientos (o sea que hubo 30 rebotes en el aro defensivo de A) entonces A capturó 66% de los rebotes en su aro (20 de 30). Pero si B erró 25 tiros, A tomó 80% de los rebotes (20 de 25).
Esto hace que, para evaluarlo correctamente, definamos: DR% como porcentaje de rebotes defensivos y OR% porcentaje de rebotes ofensivos.  

###2.5.1 Tasa de rebotes ofensivos
$% de rebotes ofensivos = [OR/(OR+op DR)]*100$

- OR (ofensive rebounds): rebotes ofensivos
- Op DR (oponent defensive rebounds): rebotes defensivos del rival

###2.5.2 Tasa de rebotes defensivos
$% de rebotes defensivos = [DR/(DR+op OR)]*100$

- DR (defensive rebounds): rebotes defensivos
- Op OR (oponent ofensive rebounds): rebotes ofensivos del rival

```{r}
data_teamopp ["Off_Reb"] <- data_teamopp["O"] /  (data_teamopp["O"]+data_teamopp["D_Opp"])

data_teamopp ["Def_Reb"] <- data_teamopp["D"] /  (data_teamopp["D"]+data_teamopp["O_Opp"])
```

## 2.6 Porcentaje de asistencias y pérdidas.
Al igual que con los rebotes y otras estadísitcas, las asistencias por juego no son un buen parámetro, ya que dependen del ritmo de juego. Más preciso es calcular las asistencias expresadas en posesiones terminan con una pérdida de balón. Habitualmente expresado en porcentaje.

### 2.6.1 Porcentaje de asistencias
Se calculan mediante la siguiente fórmula:

$% de asistencias = (asistencias/posesiones)*100$

```{r}
data_teamopp ["Pct_ass"] <- data_teamopp["As"] /  (data_teamopp["Poss"])

data_teamopp ["Pct_ass_opp"] <- data_teamopp["As_Opp"] /  (data_teamopp["Poss"])
```

###2.6.2 Porcentaje de pérdidas
Lo mismo ocurre con las pérdidas. No es lo mismo perder 10 pelotas en un partido en que hubo 100 posesiones, que en uno que hubo 80. Por eso es mejor calcular las pérdidas cada 100 posesiones. El valor ideal depende del ritmo de juego, pero podríamos decir que el objetivo sería tener menos de 15% de TO y provocar en el oponente más de 15%.
La fórmula es:
$% de pérdidas = (pelotas pérdidas/posesiones)*100$

```{r}
data_teamopp ["Pct_To"] <- data_teamopp["To"] /  (data_teamopp["Poss"])

data_teamopp ["Pct_To_opp"] <- data_teamopp["To_Opp"] /  (data_teamopp["Poss"])
```

## 2.7 Tiros libres, respecto a tiros de campo (FTM/FGA).
Es simplemente una manera de expresar el número de veces que un equipo va a la línea y cuántas veces envía al oponente a la línea. Esta considerado (junto con el effective field goal percentage, la tasa de rebotes ofensivos y la tasa de pérdidas) uno de los cuatro factores con los que se miden los partidos. 
La fórmula es:
$ Libres por lanzamientos de cancha = (libres convertidos/tiros de cancha intentados) * 100$

```{r}
data_teamopp["FTR"] <- data_teamopp["FTM"] /  (data_teamopp["x2A"]+ data_teamopp["x3A"])

data_teamopp["FTR_opp"] <- data_teamopp["FTM_Opp"] /  (data_teamopp["x2A_Opp"]+ data_teamopp["x3A_Opp"])
```

## 2.8 Expected wins (triunfos esperados)
Para ganar, obviamente hay que meter más puntos que el rival. Existe un cálculo (comprobado en la NBA, baloncesto FIBA y universitario) que de acuerdo a los puntos convertidos y recibidos, se puede estimar la cantidad de partidos que habría que haber ganado. Suele correlacionar muy bien con la realidad. 

$Triunfos esperados = eficiencia ofensiva^14/(eficiencia ofensiva^14+eficiencia defensiva^14)$

```{r}
data_teamopp ["Expected_Wins"] <- data_teamopp["Off_Rat"]^14 /  (data_teamopp["Off_Rat"]^14+data_teamopp["Def_Rat"]^14)
```

## Carga de datos originales

El primer paso que tenemos que realizar es cargar el fichero csv _euroleague_stats_per_game.csv_ que contiene el dataset con los datos individuales por partido:
```{r,eval=TRUE,echo=TRUE}
data <- read.csv2('../csv/euroleague_stats_per_game.csv')
```
Hemos utilizado la función `read.csv2` ya que el fichero a cargar está en formato _csv_ español, es decir, los separadores son el caracter `;`.

Mostramos los primeros registros del dataset para verificar que los datos se han cargado correctamente:
```{r,eval=TRUE,echo=TRUE}
head(data)
```

Mostramos el número de registros transmitidos:
```{r,eval=TRUE,echo=TRUE}
nrow(data)
```

****
# Limpieza de los datos

El dataset dispone de `r nrow(data)` registros y `r ncol(data)` variables. Estas variables son:

* **MatchId:** identificador único de partido.
* **Team:** equipo al que pertenece el jugador.
* **PlayerNumber:** número del jugador.
* **PlayerName:** nombre del jugador.
* **Min:** minutos jugados.
* **Pts:** puntos anotados.
* **2FG:** tiros de dos (metidos-anotados).
* **3FG:** tiros de tres (metidos-anotados).
* **FT:** tiros libres (metidos-anotados).
* **O:** rebotes ofensivos.
* **D:** rebotes defensivos.
* **T:** rebotes totales.
* **As:** asistencias.
* **St:** recuperaciones.
* **To:** pérdidas.
* **Fv:** tapones a favor.
* **Ag:** tapones en contra.
* **Cm:** faltas cometidas.
* **Rv:** faltas recibidas.
* **PIR:** valoración del jugador.

En total disponemos de estadísticas de `r length(table(data$MatchId))` partidos y de `r length(table(data$PlayerName))` jugadores diferentes. 

## Tratamiento de datos
## Elementos vacíos
## Identificación y tratamiento de valores extremos

****
# Análisis de los datos

FALTA POR HACER

## Selección de los grupos de datos que se quieren analizar/comparar
## Comprobación de la normalidad y homogeneidad de la varianza
## Pruebas estadísticas para comparar los grupos de datos
### Contraste de hipótesis
### Correlaciones
### Regresiones

****
# Exportación de datos finales

A continuación vamos a exportar nuestro _dataframe_ final a un archivo csv. Este archivo se llamará _euroleague_stats_per_game_clean.csv_. Utilizamos la función `write.csv2()` para exportar el fichero en formato _csv_ español:
```{r,eval=TRUE,echo=TRUE}
write.csv2(data, row.names = FALSE, file = "../csv/euroleague_stats_per_game_clean.csv")
```

Este nuevo dataset también está disponible en el repositorio de _GitHub_ mencionado en el primer apartado de este documento.

****
# Representación de los resultados a partir de tablas y gráficas

FALTA POR HACER

****
# Resolución del problema

FALTA POR HACER

****
# Contribuciones al trabajo

**Contribuciones**              |  **Firma**                    | 
--------------------------------|:-----------------------------:|
Selección del dataset           | MSP, AAG
Creación del repositorio GitHub | MSP, AAG
Desarrollo código en R          | MSP, AAG
Redacción de las respuestas     | MSP, AAG