---
title: 'Práctica 2: Limpieza y análisis de datos'
author: "Miguel Santos Pérez  y Alejandro Arzola García"
date: "17 de junio de 2020"
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../pdf") })
output:
  pdf_document:
    number_sections: yes
    toc: yes
    toc_depth: '2'
  html_document:
    df_print: paged
    toc: yes
    toc_depth: '2'
subtitle: UOC - Tipología y ciclo de vida de los datos
toc-title: Índice
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\newpage
# Descripción del dataset

En la Práctica 1 de la asginatura de _Tipología y ciclo de vida de los datos_ se creó un proceso _web scraping_ en el que se obtuvieron los datos relacionados a todos los partidos y las estadísticas individuales de todos los jugadores de la actual temporada (2019-2020) de la [\textcolor{blue}{Euroliga}](https://www.euroleague.net/), la máxima competición de clubes de baloncesto de Europa. 

El objetivo final era contribuir al aumento de explotación de los datos para los equipos europeos y tratar de igualar lo que se realiza en América con las poderosas franquicias de [\textcolor{blue}{NBA}](https://es.nba.com/?gr=www).

Mediante el proceso de obtención de datos realizado en _Python_ que comentamos anteriormente, conseguimos crear dos datasets: el primero contiene los datos generales de un partido (nombre de los equipos, puntuación de cada equipo, fecha y hora del partido) y el segundo contiene más de quince estadísticas individuales para cada jugador por cada partido (puntos, minutos, rebotes, asistencias, ...). Este trabajo está disponible en un repositorio de _GitHub_ al que se puede acceder haciendo click [\textcolor{blue}{aquí}](https://github.com/aarzola-uoc/practica1-tycvd).

Para esta segunda práctica queremos seguir progresando para lograr este objetivo y por ello vamos a utilizar los datasets que hemos mencionado para realizar un análisis estadístico.

Los datasets y el código utilizado para generar el análisis estadístico que se desarrolla a continuación está disponible en el siguiente repositorio de _GitHub_:

* \textcolor{blue}{https://github.com/aarzola-uoc/practica2-tycvd}

****
# Integración y selección de los datos de interés a analizar

Tras realizar un análisis en profundidad de los dos datasets de los que disponemos, hemos tomado la decisión de utilizar únicamente el que contiene las estadísticas individuales por partido de cada jugador. 

Los datos relevantes del primer dataset son exclusivamente los nombres de los equipos y el marcador. Sin embargo, estos datos son posibles calcularlos a partir del segundo dataset, incluso aumentar los datos de equipo ya que son la suma de las estadísticas de todos los jugadores para cada partido.

En base a esto, hemos decidido que se creará un nuevo dataset utilizando código R, a partir del dataset de estadísticas de los jugadores, que tendrá las estadísticas de cada equipo por partido (suma de cada jugador es el total del equipo).

Además vamos a calcular una serie de estadísticos muy interesantes y que permiten un análisis mucho más técnico y útli para los equipos. Estos estadísticos son.....
**FALTA POR HACER (Miguel): definición de estadísticos**


# 0. Carga de ficheros

Una vez realizado el webscrapping, cargamos los ficheros en $R$ para trabajar con ellos. 

```{r}
setwd("C:/Users/USER-PC/Desktop/tipologia")

data_scoreboards <- read.csv(file="euroleague_scoreboards.csv", header=TRUE,  sep=";", stringsAsFactors = FALSE)
data_euroleague <- read.csv(file="euroleague_stats_per_game.csv", header=TRUE, sep=";", stringsAsFactors = FALSE)
```

*MatchId* es una variable que necesitamos para cruzar ambos dataset. Por lo tanto, homogeneizamos su nombre.

```{r}
names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
```




# 1. Preprocesamiento de datos
## 1.1 Asignación de missings

Realizamos el preprocesamiento de datos. Informaremos como 0 aquellas variables sin informar, ya que son realmente 0s puesto que corresponden a jugadores que no han jugado.

```{r}
data_euroleague$Pts[data_euroleague$Pts=="-"]<-"0"
data_euroleague$Pts <- as.numeric(data_euroleague$Pts)

data_euroleague$O[data_euroleague$O=="-"]<-"0"
data_euroleague$O <- as.numeric(data_euroleague$O)

data_euroleague$D[data_euroleague$D=="-"]<-"0"
data_euroleague$D <- as.numeric(data_euroleague$D)

data_euroleague$T[data_euroleague$T=="-"]<-"0"
data_euroleague$T <- as.numeric(data_euroleague$T)

data_euroleague$As[data_euroleague$As=="-"]<-"0"
data_euroleague$As <- as.numeric(data_euroleague$As)

data_euroleague$St[data_euroleague$St=="-"]<-"0"
data_euroleague$St <- as.numeric(data_euroleague$St)

data_euroleague$To[data_euroleague$To=="-"]<-"0"
data_euroleague$To <- as.numeric(data_euroleague$To)

data_euroleague$Fv[data_euroleague$Fv=="-"]<-"0"
data_euroleague$Fv <- as.numeric(data_euroleague$Fv)

data_euroleague$Ag[data_euroleague$Ag=="-"]<-"0"
data_euroleague$Ag <- as.numeric(data_euroleague$Ag)

data_euroleague$Cm[data_euroleague$Cm=="-"]<-"0"
data_euroleague$Cm <- as.numeric(data_euroleague$Cm)

data_euroleague$Rv[data_euroleague$Rv=="-"]<-"0"
data_euroleague$Rv <- as.numeric(data_euroleague$Rv)

data_euroleague$PIR[data_euroleague$PIR=="-"]<-"0"
data_euroleague$PIR <- as.numeric(data_euroleague$PIR)

## Modificamos la variable tiempo
data_euroleague$Min[data_euroleague$Min=="0"]<-"0:00"
data_euroleague$Min[data_euroleague$Min=="DNP"]<-"0:00"
```

## 1.2 Tratamiento de variables
Para poder trabajar con las variables, necesitamos tratarlas. Así, realizaremos las siguientes modificaciones:
- *Min*: La variable minutos la pasaremos a formato decimal.
- *Tiros*: Las variables tiros de dos, tiros de tres y tiros libres, se encuentran en formato "M/A" donde M es convertidos (made) y A intentados (attempts). Por cada una de ellas, crearemos por lo tanto dos variables, separando los aciertos de los intentos.
- **

```{r}
data_euroleague$Min <- sapply(strsplit(data_euroleague$Min,":"),
  function(x) {
    x <- as.numeric(x)
    x[1]+x[2]/60
    }
)

## Modificamos la variables tiros de 2
data_euroleague$X2FG[data_euroleague$X2FG=="-"]<-"0/0"
data_euroleague$X2FG[data_euroleague$X2FG=="0"]<-"0/0"
data_euroleague$x2M <- sapply(strsplit(data_euroleague$X2FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$x2A <- sapply(strsplit(data_euroleague$X2FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)


## Modificamos la variables tiros de 3
data_euroleague$X3FG[data_euroleague$X3FG=="-"]<-"0/0"
data_euroleague$X3FG[data_euroleague$X3FG=="0"]<-"0/0"
data_euroleague$x3M <- sapply(strsplit(data_euroleague$X3FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$x3A <- sapply(strsplit(data_euroleague$X3FG,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)


## Modificamos la variables tiros libres
data_euroleague$FT[data_euroleague$FT=="-"]<-"0/0"
data_euroleague$FT[data_euroleague$FT=="0"]<-"0/0"
data_euroleague$FTM <- sapply(strsplit(data_euroleague$FT,"/"),
  function(x) {
    x <- as.numeric(x)
    x[1]
    }
)
data_euroleague$FTA <- sapply(strsplit(data_euroleague$FT,"/"),
  function(x) {
    x <- as.numeric(x)
    x[2]
    }
)
```

## 1.3 Agregación de datos

Para cada equipo y partido agregamos los datos.

```{r}
library(dplyr)
data_team <- data_euroleague %>% group_by(Team, MatchId) %>%
  select_if(is.numeric) %>%
  summarise_each(funs(sum))

data_team[c("PlayerNumber")] <- NULL
```

## 1.4 Enriquecimiento de los datos. Datos del oponente.
Durante un encuentro de baloncesto, es tan importante medir lo que tu equipo ha hecho como lo que tu equipo ha recibido. Por lo tanto, buscamos enriquecer la información por partido de cada equipo añadiendo la información del oponente. Para ello, utilizaremos la tabla de scores para completar así los registros.

```{r}
library(dplyr)

names(data_scoreboards)[names(data_scoreboards) == "Id"] <- "MatchId"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "VisitingTeam"] <- "Opponent"


library(plyr)
df_1 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_1["Local"] <- 1


names(data_scoreboards)[names(data_scoreboards) == "Team"] <- "HomeTeam"
names(data_scoreboards)[names(data_scoreboards) == "Opponent"] <- "Team"
names(data_scoreboards)[names(data_scoreboards) == "HomeTeam"] <- "Opponent"
df_2 <- merge(data_team, data_scoreboards, by=c("MatchId","Team"))
df_2["Local"] <- 0

data_team <- bind_rows(df_1,df_2)

data_team[c("Date")] <- NULL
data_team[c("HomeScore")] <- NULL
data_team[c("VisitingScore")] <- NULL
data_team[c("Link")] <- NULL

data_team2 <- data_team [c("MatchId","Team","Min","Pts","O","D","T","As","St","To","Fv","Ag","Cm","Rv","PIR","x2M","x2A","x3M","x3A","FTM","FTA")]

names(data_team2)[names(data_team2) == "Pts"] <- "Pts_Opp"
names(data_team2)[names(data_team2) == "O"] <- "O_Opp"
names(data_team2)[names(data_team2) == "D"] <- "D_Opp"
names(data_team2)[names(data_team2) == "T"] <- "T_Opp"
names(data_team2)[names(data_team2) == "As"] <- "As_Opp"
names(data_team2)[names(data_team2) == "St"] <- "St_Opp"
names(data_team2)[names(data_team2) == "To"] <- "To_Opp"
names(data_team2)[names(data_team2) == "Fv"] <- "Fv_Opp"
names(data_team2)[names(data_team2) == "Ag"] <- "Ag_Opp"
names(data_team2)[names(data_team2) == "Cm"] <- "Cm_Opp"
names(data_team2)[names(data_team2) == "Rv"] <- "Rv_Opp"
names(data_team2)[names(data_team2) == "PIR"] <- "PIR_Opp"
names(data_team2)[names(data_team2) == "x2M"] <- "x2M_Opp"
names(data_team2)[names(data_team2) == "x2A"] <- "x2A_Opp"
names(data_team2)[names(data_team2) == "x3M"] <- "x3M_Opp"
names(data_team2)[names(data_team2) == "x3A"] <- "x3A_Opp"
names(data_team2)[names(data_team2) == "FTM"] <- "FTM_Opp"
names(data_team2)[names(data_team2) == "FTA"] <- "FTA_Opp"

data_teamopp <- merge(data_team, data_team2, by.x=c("MatchId","Opponent"),  by.y=c("MatchId","Team"))
data_teamopp["y.min"]<-NULL
```


## Carga de datos originales

El primer paso que tenemos que realizar es cargar el fichero csv _euroleague_stats_per_game.csv_ que contiene el dataset con los datos individuales por partido:
```{r,eval=TRUE,echo=TRUE}
data <- read.csv2('../csv/euroleague_stats_per_game.csv')
```
Hemos utilizado la función `read.csv2` ya que el fichero a cargar está en formato _csv_ español, es decir, los separadores son el caracter `;`.

Mostramos los primeros registros del dataset para verificar que los datos se han cargado correctamente:
```{r,eval=TRUE,echo=TRUE}
head(data)
```

Mostramos el número de registros transmitidos:
```{r,eval=TRUE,echo=TRUE}
nrow(data)
```

****
# Limpieza de los datos

El dataset dispone de `r nrow(data)` registros y `r ncol(data)` variables. Estas variables son:

* **MatchId:** identificador único de partido.
* **Team:** equipo al que pertenece el jugador.
* **PlayerNumber:** número del jugador.
* **PlayerName:** nombre del jugador.
* **Min:** minutos jugados.
* **Pts:** puntos anotados.
* **2FG:** tiros de dos (metidos-anotados).
* **3FG:** tiros de tres (metidos-anotados).
* **FT:** tiros libres (metidos-anotados).
* **O:** rebotes ofensivos.
* **D:** rebotes defensivos.
* **T:** rebotes totales.
* **As:** asistencias.
* **St:** recuperaciones.
* **To:** pérdidas.
* **Fv:** tapones a favor.
* **Ag:** tapones en contra.
* **Cm:** faltas cometidas.
* **Rv:** faltas recibidas.
* **PIR:** valoración del jugador.

En total disponemos de estadísticas de `r length(table(data$MatchId))` partidos y de `r length(table(data$PlayerName))` jugadores diferentes. 

## Tratamiento de datos
## Elementos vacíos
## Identificación y tratamiento de valores extremos

****
# Análisis de los datos

FALTA POR HACER

## Selección de los grupos de datos que se quieren analizar/comparar
## Comprobación de la normalidad y homogeneidad de la varianza
## Pruebas estadísticas para comparar los grupos de datos
### Contraste de hipótesis
### Correlaciones
### Regresiones

****
# Exportación de datos finales

A continuación vamos a exportar nuestro _dataframe_ final a un archivo csv. Este archivo se llamará _euroleague_stats_per_game_clean.csv_. Utilizamos la función `write.csv2()` para exportar el fichero en formato _csv_ español:
```{r,eval=TRUE,echo=TRUE}
write.csv2(data, row.names = FALSE, file = "../csv/euroleague_stats_per_game_clean.csv")
```

Este nuevo dataset también está disponible en el repositorio de _GitHub_ mencionado en el primer apartado de este documento.

****
# Representación de los resultados a partir de tablas y gráficas

FALTA POR HACER

****
# Resolución del problema

FALTA POR HACER

****
# Contribuciones al trabajo

**Contribuciones**              |  **Firma**                    | 
--------------------------------|:-----------------------------:|
Selección del dataset           | MSP, AAG
Creación del repositorio GitHub | MSP, AAG
Desarrollo código en R          | MSP, AAG
Redacción de las respuestas     | MSP, AAG